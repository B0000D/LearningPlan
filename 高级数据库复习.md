# 高级数据库复习

## 重点

第1章:看看就行

第2章:2.5 习题2.5.1

2.7 习题2.7.2

第3章 3.1 习题3.3.3 3.3.5

3.2 图3-2,1 3-2,3 3-2,4

3.3

第4章

4.1 

4.2 伪代码 步骤

4.4 **4.4.2** **4.4.3** 4.4.5步骤

习题4.4.1步骤 4.4.4 I/O 复杂度

第5章

5.1 sql语句-> 语法树 图5-3,5-4,5-5,习题5.1.3

5.4 看看就行

第6章

6.1 习题6.1.1

6.2 根据事务操作画表 描述状态 图6-2

6.3 图6-3 6-5 6-6 表示形式 第几步出问题 对应使用什么操作 产生什么结果

习题6.2.3

第7章

7.2 概念 判断题 优先图 习题7.2.5

7.8 图7-3,9 四条规则(p236) 习题7.8.1

第8章

8.2 等待图 图8-8 8-9 8-10

第11章

11.1

11.2 A-Priori算法

习题11.2.1

第12章

12.2 PageRank 习题12.2.1 12.2.2







## 2.5 组织磁盘上的数据

在磁盘上存储数据库

用一个记录表示一个数据元素,在磁盘块中的连续字节存放

**记录与磁盘块的基本组织技术**

## 2.5.1 定长记录

最简单类型的记录由定长字段组成,元组的每一个属性对应一个字段

通常字段的起始地址是4或8的倍数

在内存中有效访问记录是必要的

#### 记录以记录的 **首部**开始,包括以下信息:

1.指向该记录中存储数据的**模式**的指针

2.记录长度

3.时间戳 最后一次被修改或被读的时间

4.指向记录的字段的指针

#### 例

```sql
create table MovieStar(
	name CHAR(30) PRIMARY KEY,
	address VARCHAR(255),
    gender CHAR(1),
  	birthday DATE
)
```

该关系的元组有一个头部和以下4个字段:

1.name字段,需要30字节,假设字段以4的倍数开始,为name分配32字节

2.address VARCHAR属性需要定长字节片段,比最大长度多一个字节,255+1=256字节

3.gender属性 一个字节,分配4个字节使下一个字段的起始地址是4的倍数

4.birthday SQL DATE值,是1个10字节的字符串,分配12个字节(4的倍数)

#### 对应记录格式(316字节)

从0开始,分别是

**header**

* 指向记录模式的指针	0-4
* 记录长度    4-8       
* 时间戳    8-12



* name字段    12-44
* address字段    44-300
* gender    300-304
* birthdate    304-316

### 定长记录在块中的放置

标识关系元组的记录存储在磁盘块中,需要存取或修改时,记录被移进主存

| 块首部  | 记录1  | 记录2  | .... | 记录n  |
| ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |

除了记录,有一个可选的块首部,存储以下信息:

1.与一个或者多个块的链接,构成一个块的网络

2.这个块在该网络中扮演的角色信息

3.块的元组属于哪个关系

4.每一条记录在块内的偏移量目录

5.块最后一次修改/存取的时间戳

### 疑问

#### 例2.16

上例格式的记录,假设有4096字节的块,12个字节用于块首部,剩余4084字节由数据使用.装入12条所给316字节格式的记录,**每一块有292字节是被浪费的空间?**

### 习题2.5.1

字段由如下顺序记录:

长度为23的字符串	2字节整数	SQL日期	SQL时间

如果:	记录占用多少字节?

1.字段可在任何字节处开始  4*3+23+2+10+6

2.字段必须在8的倍数的字节处开始

3.字段必须在4的倍数的字节处开始

## 2.7 变长数据和记录

除了有固定模式,且模式是定长字段的列表,还希望表示:

* 大小变化的数据项  : 只分配实际空间
* 重复字段: 表示多对多关系
* 可变格式记录
* 极大的字段:如属性值很大的属性

### 2.7.1 具有变长字段的记录

定长字段放在变长字段之前,首部写入如下信息:

* 记录长度
* 指向除第一个以外所有的变长字段起始处的指针(第一个变长字段一定在记录的定长部分之后)

| 其他首部信息 | 记录长度 | 指向第二个变长地段address | 定长gender | 定长birthdate | 变长name | 变长address |
| ------ | ---- | ---------------- | -------- | ----------- | ------ | :-------- |
|        |      |                  |          |             |        |           |



### 2.7.2 具有重复字段的记录

两种表示方法:

1.假设定长字段F的出现次数可变,将F的每次出现放在一起,在记录首部放一个指针,指向F出现的第一个位置,剩余F的出现位置可通过F的固定长度偏移

| 其他首部信息 | 记录长度 | 指向第二个变长address | 指向重复影片字段 | name | address | 影片   | 影片   | .... | 影片   |
| ------ | ---- | -------------- | -------- | ---- | ------- | ---- | ---- | ---- | ---- |
|        |      |                |          |      |         |      |      |      |      |



2.保持记录定长,将变长部分(变长字段/重复字段)放在另一个块上.记录中存储

* ### 指向每一个重复字段开始处的指针

* 重复次数或者重复结束处

| 记录首部信息 | 指向name | name长度 | 指向address | address长度 | 指向影片引用 | 引用个数 |
| ------ | ------ | ------ | --------- | --------- | ------ | ---- |
|        |        |        |           |           |        |      |

|      | address |      | name |      | 影片   | 影片   | ...  | 影片   |
| ---- | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |         |      |      |      |      |      |      |      |



**优点**:

* 保持记录定长 有效搜索 减少开销

**缺点:**

* 增加进行的磁盘I/O数目

**折中方案**

在记录定长部分额外存储以下信息

* 重复字段次数合理的出现
* 指向重复字段其他地方出现的实例的指针
* 其他出现的次数

### 2.7.3 可变格式的记录

用带标记的字段序列来表示,每个带标记的字段由**字段值**以及**字段值前的关于字段的角色信息**组成

* 属性或字段名

* 字段类型

* 字段长度

  ​

  | 姓名的编码 | 字符串类型 | 长度   |                | 拥有的餐馆编码 | 字符串类型 | 长度   |                  | ...  |
  | ----- | ----- | ---- | -------------- | ------- | ----- | ---- | ---------------- | ---- |
  | N     | S     | 14   | Clint Eastwood | R       | S     | 16   | Hog's Breath Inn | ...  |

### 2.7.4 不能装入一个块中的记录

对于大值数据通常不能装入一个块中,比如视频音频片段.

使用 **跨块记录**

**记录片段:**出现在一个块中的记录

**跨块:**一个具有两个或多个片段的记录

**不跨块**:不跨越块边界

对于 **跨块记录**,需要额外的首部信息

* 每一条记录/片段首部包含一个二进制位,指明是否是一个片段
* 若是片段,需要几个二进制位指明是否为所属记录的第一个/最后一个
* 对同一条记录有下一个/前一个片段,需要指向这些片段的指针

**块1:**

| 块首部  | 记录首部 | 记录1  | 指向2-b | 记录2-a |
| ---- | ---- | ---- | ----- | ----- |
|      |      |      |       |       |

**块2:**

| 指向2-a | 记录2-b | 记录3  |
| ----- | ----- | ---- |
|       |       |      |

这样就可以把3个大约为块的60%大小的记录存储在2个块中

## 2.7.5 BLOB

**二进制大对象或BLOB:**

真正大的记录值/记录字段值,各种格式的图像,MPEG格式的电影或各种信号

**BLOB的存储**

必须存储在一系列块中,最好在磁盘的一个或多个柱面上连续分配(能有效检索)

有必要将BLOB进行分割,在几个磁盘中交替存储,有利于同时检索,提高检索效率

**BLOB的检索**

只传送记录的"小"字段,同时允许客户端一次一个的请求BLOB块,而与记录的其余部分无关

客户端能请求BLOB内部的部分,而不必接收整个BLOB.那么DBMS需要合适的索引结构

## 2.7.6 列存储

将元组保存为记录的另一个方法是将每一列保存为一个记录,可能被存放在多个磁盘块中.

通常可能进行数据压缩,通过 **位序列存储**的方式压缩数据

### 习题2.7.2

一个病人记录包括以下

定长字段:病人的出生日期,社会保险号码,病人ID,每一个字段都是9字节长

变长字段:姓名,住址和病史

记录内一个指针需要8字节,记录长度是一个2字节整数,不包括变长字段空间

**这条记录需要多少字节?**

变长字段姓名,住址和病史的长度都符合均匀分布

姓名的范围为20-60字节,住址的范围是40-80字节,病史的范围是0-2000字节.**一个病人记录的平均长度是多少?**



## 3.1 索引结构基础

**文件:**构成存储结构

* 数据文件:存储一个关系,可以拥有一个或多个索引文件
* 索引文件:建立查找键和数据记录之间的关联,查找键的指针指向与查找键具有相同属性值的记录

通常为每个数据块在索引文件中设一个索引项

**主索引**能确定记录在数据文件中的位置,而 **辅助索引**不能

在关系的主键上建立主索引,在其他的属性上建立辅助索引

### 3.1.1 顺序文件

**顺序文件:**对关系中的元组按主键进行排序而生成的文件.关系中的元组按照这个次序分布在多个数据块中

### 3.1.2 稠密索引

如果记录是排好序的,我们就可以在记录上建立稠密索引

块中只存放记录的键以及指向记录本身的指针

稠密索引文件中的索引块保持键的顺序与文件中的排序顺序一致

**比数据文件节省存储空间 每次查询只用一次I/O操作**

**稠密索引的高效查找**

* 索引块数量通常比数据块少
* 可以使用二分查找来查找键值
* 足够小的索引文件可以存放在主存缓冲区中,查找键值只涉及主存访问而不需要I/O操作

### 3.1.3 稀疏索引

**稀疏索引:**职位数据文件的每个存储块设一个键-指针对,比稠密索引节省了更多存储空间,但查找给定值记录需要更多的时间

条件:数据文件按照某个查找键排序

找出键值为K的记录:
1.查找到键值小于或等于K的最大键值

2.根据相应指针找到相应的数据块

3.搜索数据块找到键值为K的记录

### 3.1.4 多级索引

在索引上再建索引,提高第一级索引的使用效率

### 疑问

**一级索引可以稠密/稀疏 二级和更高级的索引必须是稀疏的,因为一个索引上的稠密索引将需要和其前一级索引同样多的键-指针对,因为也就需要同样的存储空间**

### 3.1.5 辅助索引

可用于任何索引目的,有助于查找给定一个或多个字段值的记录

不决定数据文件中记录的存放位置,仅能告诉我们记录的当前存放位置

**辅助索引总是稠密索引(无法预测未显示指明的记录位置)**

比使用主索引可能需要多得多的磁盘I/O

存在空间浪费->3.1.7

### 3.1.6 辅助索引的运用

**建立附加索引**

**某些数据结构的主键索引**

* 堆
* 聚集文件 :关系R和S的元组具有多对一的对应关系,可以把R的每个元组和S中相关的元组存储在一起

### 3.1.7 辅助索引中的间接

使用一个称为 **桶**的间接层

每个查找键K有一个键-指针对,指针指向一个桶文件,存放K的桶,直到索引指向的下一个位置,其间指针指向索引键值为K的所有记录

**节省空间**

**节省I/O开销**

在不访问数据文件记录的前提下利用桶的指针来帮助回答一些查询

对于多条件查询,在主存中对指针集合求交,然后检索交集中指针指向的记录

### 3.1.8 文档检索和倒排索引

查询相关文档的最简单,最常见的形式:

* 看成关系Doc的元组,有很多bool属性对应文档的某个词是否出现
* 关系Doc的每个属性上都建有辅助索引,其中只有查找键值为TRUE的索引项
* 把所有索引合成一个,称为**倒排索引** 

**倒排索引**

本身由一系列词-指针对组成 

词是索引的查找键

存储在连续的块中

指针指向桶文件中的位置,桶文件中包含

* 指向文档本身的指针
* 指向词的一个出现的指针

## 3.2 B-树

* 能自动保持与数据文件大小相适应的索引层次
* 对所使用的存储块空间进行管理,使每个块的存储程度在半满与全满之间

具体针对B+树

### 3.2.1 B-树的结构

把存储块组织成一棵 **平衡**的树(树根到树叶的所有路径都一样长)

通常有三层:根	中间层	叶

每个B-树索引都有一个参数n,决定了所有存储块的布局.

每个存储块存放n个查找键值和n+1个指针

B树的存储块限制:

* 叶结点中的键是数据文件中的键的拷贝
* 根结点中至少有两个指针被使用
* 叶结点中,最后一个指针指向它右边的下一个叶结点存储块,即下一个键值大于它的块 其他指针中至少有(n+1)/2(向下取整)个指针被使用且指向数据记录
* 在内层结点中,所有的n+1个指针都可以用来指向B树中下一层的块,至少有(n+1)/2(向下取整)个指针被使用
* 所有被使用的键和指针通常都存放在数据块的开头位置,叶节点n+1个指针除外(指向下一个叶结点)

### 3.2.2 B树的应用

建立索引的强有力工具

实例

* B树查找键是数据文件的主键 稠密索引
* 数据文件按主键排序 系数索引
* 数据文件按非键属性排序 且该属性是B树的查找键

### 疑问

p58 划线

### 3.2.3 B-树的查找

假设叶结点中没有重复键	B-树是稠密索引

数据文件中出现的每个查找键都会在叶结点出现

假设有一棵B-树索引,想找出查找键值为K的记录,从根到叶递归查找:

* 基础:若处于叶结点上,就在键值中查找对应键值为K的指针
* 归纳:若处于内部结点 根据K1 K2...Kn的范围来查找

### 3.2.4 范围查询

找出范围在[a,b]之间的所有键值,通过一次查找来找出键a

到达可能出现a的叶结点,在该结点中查找键a或大于a的那些键,如果当前结点中不存在比b大的键,就跟踪指向下一个叶结点的指针继续查找[a,b]之间的所有键值

### 3.2.5 B-树的插入

插入一个新键到B-树

* 在适当的叶结点中为新键找到空闲空间,有的话就把键放在那里
* 如果叶结点中没有空间,把该叶结点分裂成两个并且把其中的键分到这两个新结点中,每个新结点正好有一半或超过一半的键
* 在较高层次上递归地使用插入策略:如果有空间,则插入;如果没有,则分裂这个父节点且继续向高层推进
* 如果试图插入到根结点中且根结点没有空间,分裂根结点成两个结点且在更上一层创建一个新的根结点,这个根结点有两个刚分裂的结点作为子结点

### 3.2.6 B-树的删除

要删除一个具有给定键K的记录,先定位该记录和它在B-树结点中的键-指针对

删除后可能违背了对键数目的约束 需要对键的数目仅次于最小数目的结点N:

* 如果与结点相邻N相邻的兄弟中有一个的键和指针超过最小数目,那它的一个键-指针对可以移到结点N中并保持键的顺序
* 如果相邻的两个兄弟中没有一个能提供键值给结点N时,调整父结点的键,然后删除父结点的一个键和指针,如果父节点键数目还不够,在父节点中递归使用这种方法

### 3.2.7 B-树的效率

忽略B-树重组的I/O开销

一般取3作为B-树的层数

B树根结点是永久缓冲在主存中的绝佳选择,这样查找3层的B树只需两次磁盘读操作,如果第二层结点块也保存在缓冲区,就只需要一次磁盘I/O加上处理数据本身的磁盘I/O

## 3.3 散列表

**桶数组**

一个序号从0到B-1的数组,包含B个链表的头,每一个对应于数组中的一个桶

**散列函数**

以查找键为参数并计算出一个介于0到B-1的整数,如果记录的查找键为K,我们通过将该记录链接到桶号为h(K)的桶表中来存储它

### 3.3.1 辅存散列表

只要给一个i,桶i的第一个存储块的位置就可以被找到

把每个桶第一个存储块存放到磁盘固定连续的位置,从而根据整数i计算出桶i的位置

### 3.3.2 散列表的插入

插入查找键为K的新记录时,计算h(K)

如果桶号为h(K)的桶还有空间,把该记录存放到此桶的存储块或溢出块(没有空间)中

如果桶的所有存储块都没有空间,增加一个新的溢出块到该桶的链上,并存入新记录

### 3.3.3 散列表的删除

找到桶号为h(K)的桶且从中搜索查找键为K的记录,继而将找到的记录删除

如果可以移动记录,可以合并同一链上的存储块

### 3.3.4 散列表索引的效率

如果有足够的桶,绝大多数桶都只由单个块组成,那么一般的查询只需要一次磁盘I/O,文件插入删除只需要两次磁盘I/O,比之前的索引效率高得多

如果文件不断增长,桶的链表中都会有很多块,增加了查找所需的磁盘I/O,因此要设法减少每个桶的块数

讨论 **动态散列表** 

3.3.5

3.3.7

### 3.3.5 可扩展散列表

在简单的静态散列表结构上增加了:

* 引入一个间接层,用指向块的指针数组来表示桶
* 指针数组可增长,长度总是2的幂
* 如果某些桶中的所有记录可以放在一个块中,这些桶可以共享一个块
* 散列函数h为每个键计算出一个K位二进制序列(K足够大),若i是使用的位数,桶数组将有$2^i$项

优点：如果桶数组小到可以存放在主存中，访问桶数组就不需要进行磁盘I/O

缺点：

* 桶数组需要翻倍时工作量很大（i很大时）
* 桶数翻倍后主存可能无法容纳，磁盘I/O会突然大幅增加
* 不均衡的分裂，桶数组所占空间大量浪费

### 3.3.6 可扩展散列表的插入

插入键值为K的记录:

计算h(K),取出这个二进制位序列的前i位

找到桶数组中序号为i位的项

根据该项的指针找到某个存储块B,如果B还有空间,就存入新记录

如果没有空间,根据散列值中的可用位数j来确定:

j<i,

* 分裂桶B,

* 根据第j+1位分配B中的记录,

* 该位为0保留,该位为1放入新块

* 把j+1存入小方块,表明确定资格的二进制位数

* 根据j+1位调整指针指向B或新块

  ​

  ​

j=i

* 将i加1,桶数组长度翻倍
* 继续像第一种情况一样分裂B

### 3.3.7 线性散列表

线性散列的新要点：

* 桶数n的选择总是使存储块的平均记录数保持与存储块的最大记录总数成固定比例
* 允许有溢出块
* 用作桶数组项序号的二进制位数是log2n向上取整，n是当前桶数。位数从右端开始取
* 如果一个键值为K的记录想要插入编号为a1a2a3..an的桶中,把a1a2..an当成二进制整数m,如果编号为m的桶存在,就把记录存到这个桶中.否则存入a1改为0时对应的桶

#### 三个参数

i	当前被使用的散列函数值的位数

n	当前的桶数

r	当前散列表中的记录总数

**比率r/n<=1.7**

### 3.3.8 线性散列表的插入

通过3.3.7提供的算法确定所属的桶.然后把记录存入桶中.如果桶中没有空间,创建一个溢出块链到桶上,记录存入溢出块中

如果插入后r/n值超过阈值1.7,增加下一个桶到线性散列表中

如果n>$2^i$,这时i的值加1

### 习题3.3.3

### 习题3.3.5

## 4.1 物理查询计划操作符介绍

物理查询计划由操作符构成,每一个操作符实现计划中的一步

### 4.1.1 扫描表

最基本的事情是读一个关系R的整个内容

定位关系R中元组的基本方法有两种

* 关系R存放在二级存储器的某个区域中,它的元组排放在块中.系统知道包含R的元组的块并一个接一个得到这些块 这个操作叫做 **表-扫描**
* 如果R的任意一个属性上有索引,我们可以使用这个索引来得到R的所有元组.这个操作叫做 **索引-扫描**

### 4.1.2 扫描表时的排序

**排序-扫描**

接收关系R和作为排序依据的属性组的说明,产生排好序的R

实现扫描-排序的方法

* 如果想产生按照属性a排序的关系R,a上有一个B数索引或R是按a排序的索引来存储的,扫描索引得到所需顺序的R
* 排序关系R很小,可以装进内存,使用表扫描或索引扫描来得到它的元组,再使用主存排序
* R太大以至于不能装进内存,可以使用多路归并方法(4.4.1)

### 4.1.3 物理操作符计算模型

使用磁盘I/O的数目作为衡量每个操作的代价的标准

**从磁盘中得到数据的时间比对内存中的数据做任何有用操作花费的时间都长**

比较相同操作的算法时建立在一个假设上:

* 假设任何操作符的操作对象都位于磁盘上,但操作符的结果放在内存中

### 4.1.4 衡量代价的参数

M表示一个特定的操作符执行时可以获得的内存缓冲区的数目

三类参数

* B(R)		用B(R)表示包含R的所有元组所需的块的数目
* T(R)         R中元组的数目
* V(R,[a1,a2,a3,...,an])       R中属性a1,a2,...,an对应列上不同n元组的数目

### 4.1.5 操作扫描符的I/O代价

